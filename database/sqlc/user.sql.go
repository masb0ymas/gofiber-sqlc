// Code generated by sqlc.
// versions:
//   sqlc v1.25.0
// source: user.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"gopkg.in/guregu/null.v4"
)

const countUser = `-- name: CountUser :one
SELECT COUNT(*) FROM "user" WHERE "deleted_at" IS NULL
`

func (q *Queries) CountUser(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUser)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const forceDeleteUser = `-- name: ForceDeleteUser :exec
DELETE FROM "user" WHERE id = $1
`

func (q *Queries) ForceDeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, forceDeleteUser, id)
	return err
}

const forceDeleteUsers = `-- name: ForceDeleteUsers :exec
DELETE FROM "user" WHERE id IN ($1)
`

func (q *Queries) ForceDeleteUsers(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, forceDeleteUsers, id)
	return err
}

const getUser = `-- name: GetUser :one
SELECT id, created_at, updated_at, deleted_at, fullname, email, password, phone, token_verify, address, is_active, is_blocked, role_id FROM "user" WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Fullname,
		&i.Email,
		&i.Password,
		&i.Phone,
		&i.TokenVerify,
		&i.Address,
		&i.IsActive,
		&i.IsBlocked,
		&i.RoleID,
	)
	return i, err
}

const getUserWithRelation = `-- name: GetUserWithRelation :one
SELECT u.id, u.created_at, u.updated_at, u.deleted_at, u.fullname, u.email, u.phone, u.address, u.is_active, u.is_blocked, u.role_id, r.name as role_name
  FROM "user" u
  LEFT JOIN "role" r ON u.role_id = r.id
  WHERE u.id = $1
`

type GetUserWithRelationRow struct {
	ID        uuid.UUID   `db:"id" json:"id"`
	CreatedAt null.Time   `db:"created_at" json:"created_at"`
	UpdatedAt null.Time   `db:"updated_at" json:"updated_at"`
	DeletedAt null.Time   `db:"deleted_at" json:"deleted_at"`
	Fullname  string      `db:"fullname" json:"fullname"`
	Email     string      `db:"email" json:"email"`
	Phone     null.String `db:"phone" json:"phone"`
	Address   null.String `db:"address" json:"address"`
	IsActive  bool        `db:"is_active" json:"is_active"`
	IsBlocked bool        `db:"is_blocked" json:"is_blocked"`
	RoleID    uuid.UUID   `db:"role_id" json:"role_id"`
	RoleName  null.String `db:"role_name" json:"role_name"`
}

func (q *Queries) GetUserWithRelation(ctx context.Context, id uuid.UUID) (GetUserWithRelationRow, error) {
	row := q.db.QueryRowContext(ctx, getUserWithRelation, id)
	var i GetUserWithRelationRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Fullname,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.IsActive,
		&i.IsBlocked,
		&i.RoleID,
		&i.RoleName,
	)
	return i, err
}

const getUsers = `-- name: GetUsers :many
SELECT u.id, u.created_at, u.updated_at, u.deleted_at, u.fullname, u.email, u.phone, u.address, u.is_active, u.is_blocked, u.role_id, r.name as role_name
  FROM "user" u
  LEFT JOIN "role" r ON u.role_id = r.id
  WHERE u.deleted_at IS NULL 
  OFFSET $1 LIMIT $2
`

type GetUsersParams struct {
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

type GetUsersRow struct {
	ID        uuid.UUID   `db:"id" json:"id"`
	CreatedAt null.Time   `db:"created_at" json:"created_at"`
	UpdatedAt null.Time   `db:"updated_at" json:"updated_at"`
	DeletedAt null.Time   `db:"deleted_at" json:"deleted_at"`
	Fullname  string      `db:"fullname" json:"fullname"`
	Email     string      `db:"email" json:"email"`
	Phone     null.String `db:"phone" json:"phone"`
	Address   null.String `db:"address" json:"address"`
	IsActive  bool        `db:"is_active" json:"is_active"`
	IsBlocked bool        `db:"is_blocked" json:"is_blocked"`
	RoleID    uuid.UUID   `db:"role_id" json:"role_id"`
	RoleName  null.String `db:"role_name" json:"role_name"`
}

func (q *Queries) GetUsers(ctx context.Context, arg GetUsersParams) ([]GetUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersRow
	for rows.Next() {
		var i GetUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Fullname,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.IsActive,
			&i.IsBlocked,
			&i.RoleID,
			&i.RoleName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newUser = `-- name: NewUser :one
INSERT INTO "user" (fullname, email, password, phone, token_verify, address, is_active, is_blocked, role_id)
  VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING id, created_at, updated_at, deleted_at, fullname, email, password, phone, token_verify, address, is_active, is_blocked, role_id
`

type NewUserParams struct {
	Fullname    string      `db:"fullname" json:"fullname"`
	Email       string      `db:"email" json:"email"`
	Password    string      `db:"password" json:"password"`
	Phone       null.String `db:"phone" json:"phone"`
	TokenVerify null.String `db:"token_verify" json:"token_verify"`
	Address     null.String `db:"address" json:"address"`
	IsActive    bool        `db:"is_active" json:"is_active"`
	IsBlocked   bool        `db:"is_blocked" json:"is_blocked"`
	RoleID      uuid.UUID   `db:"role_id" json:"role_id"`
}

func (q *Queries) NewUser(ctx context.Context, arg NewUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, newUser,
		arg.Fullname,
		arg.Email,
		arg.Password,
		arg.Phone,
		arg.TokenVerify,
		arg.Address,
		arg.IsActive,
		arg.IsBlocked,
		arg.RoleID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Fullname,
		&i.Email,
		&i.Password,
		&i.Phone,
		&i.TokenVerify,
		&i.Address,
		&i.IsActive,
		&i.IsBlocked,
		&i.RoleID,
	)
	return i, err
}

const restoreUser = `-- name: RestoreUser :exec
UPDATE "user" SET "deleted_at" = NULL WHERE id = $1
`

func (q *Queries) RestoreUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, restoreUser, id)
	return err
}

const restoreUsers = `-- name: RestoreUsers :exec
UPDATE "user" SET "deleted_at" = NULL WHERE id IN ($1)
`

func (q *Queries) RestoreUsers(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, restoreUsers, id)
	return err
}

const softDeleteUser = `-- name: SoftDeleteUser :exec
UPDATE "user" SET "deleted_at" = now() WHERE id = $1
`

func (q *Queries) SoftDeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, softDeleteUser, id)
	return err
}

const softDeleteUsers = `-- name: SoftDeleteUsers :exec
UPDATE "user" SET "deleted_at" = now() WHERE id IN ($1)
`

func (q *Queries) SoftDeleteUsers(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, softDeleteUsers, id)
	return err
}

const updateUser = `-- name: UpdateUser :one
UPDATE "user" SET fullname=$2, email=$3, phone=$4, address=$5, is_active=$6, is_blocked=$7, role_id=$8
  WHERE id=$1 AND "deleted_at"=NULL RETURNING id
`

type UpdateUserParams struct {
	ID        uuid.UUID   `db:"id" json:"id"`
	Fullname  string      `db:"fullname" json:"fullname"`
	Email     string      `db:"email" json:"email"`
	Phone     null.String `db:"phone" json:"phone"`
	Address   null.String `db:"address" json:"address"`
	IsActive  bool        `db:"is_active" json:"is_active"`
	IsBlocked bool        `db:"is_blocked" json:"is_blocked"`
	RoleID    uuid.UUID   `db:"role_id" json:"role_id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.ID,
		arg.Fullname,
		arg.Email,
		arg.Phone,
		arg.Address,
		arg.IsActive,
		arg.IsBlocked,
		arg.RoleID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
